# AUTOGENERATED! DO NOT EDIT! File to edit: 00_abstractions.ipynb (unless otherwise specified).

__all__ = ['AbstractNoncontextualMAB', 'AbstractContextualMAB', 'AbstractSolver', 'AbstractContextualSolver',
           'AbstractContextualSolverSingleModel']

# Cell
import numpy as np

class AbstractNoncontextualMAB(object):
    def get_probaility(self, arm):
        pass

    def get_reward(self, arm):
        pass

    def get_best_arm(self):
        pass


class AbstractContextualMAB(object):

    def __init__(self, theta, noise, linear=False):

        self.theta = theta
        self.noise = noise
        self.num_arms = len(theta)

        if linear:
            self. activation = lambda x: x
        else:
            self.activation = lambda x: 1 / (1 + np.exp(-x))

    def get_probaility(self, arm, context):
        pass

    def get_reward(self, arm, context):
        pass

    def get_best_arm(self, context):
        pass





# Cell
class AbstractSolver(object):
    def choose_arm(self):
        """choose an arm to play according to internal policy"""
        raise NotImplementedError

    def update(self, arm, reward):
        """ update internal policy to reflect changed knowledge"""
        raise NotImplementedError


# Cell
from collections import OrderedDict


class AbstractContextualSolver(object):
    def __init__(self, model_type, num_arms, num_context, model_params={}):
        self.model_list = [model_type(num_context, **model_params) for x in range(num_arms)]
        self.num_arms = num_arms
        self.num_context = num_context


    def choose_arm(self,context):
        """choose an arm to play according to internal policy"""
        raise NotImplementedError

    def update(self, arm, context, reward):
        """ update internal policy to reflect changed knowledge"""
        raise NotImplementedError



# class AbstractContextualSolverSingleModel(object):
#     def __init__(self, model_type, num_arms, num_context, model_params={}):
#         self.model = model_type(num_context+num_arms, **model_params)
#         self.num_arms = num_arms



#         num_arms = 3
#         zero_arm = np.ones(num_arms)
#         self.arms = OrderedDict({x: np.ones(num_arms) for x in range(num_arms+1)})
#         for x in self.arms:
#             self.arms[x][x %3] -=1

#         self.arms[num_arms+1] = zero_arm

#         self.num_context = num_context


#     def choose_arm(self,context):
#         """choose an arm to play according to internal policy"""
#         raise NotImplementedError

#     def update(self, arm, context, reward):
#         """ update internal policy to reflect changed knowledge"""
#         raise NotImplementedError



class AbstractContextualSolverSingleModel(object):
    def __init__(self, model_type, num_arms, num_context, model_params={}):
        self.model = model_type(num_context+num_arms, **model_params)
        self.num_arms = num_arms
        self.errors = []



        zero_arm = np.ones(num_arms)
        self.arms = OrderedDict({x: np.ones(num_arms) for x in range(num_arms)})
        arms2 = OrderedDict({x+num_arms: np.zeros(num_arms) for x in range(num_arms)})
        for x in self.arms:
            self.arms[x][x %num_arms] -=1
            arms2[x+num_arms][x%num_arms] +=1

        self.arms.update(arms2)



        self.arms[2*num_arms] = zero_arm

        self.num_context = num_context


    def choose_arm(self,context):
        """choose an arm to play according to internal policy"""
        raise NotImplementedError

    def update(self, arm, context, reward):
        """ update internal policy to reflect changed knowledge"""
        raise NotImplementedError

