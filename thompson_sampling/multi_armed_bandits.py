# AUTOGENERATED! DO NOT EDIT! File to edit: 01_multi_armed_bandits.ipynb (unless otherwise specified).

__all__ = ['sigmoid', 'non_contextual_categorical_bandit', 'contextual_categorical_bandit',
           'contextual_categorical_get_optimal_arm', 'NonlinearContextualCategoricalBandit',
           'contextual_numerical_bandit']

# Cell
import numpy as np
import scipy.stats as stats
from .abstractions import AbstractContextualMAB



def sigmoid(x):
    return 1 / (1 + np.exp(-x))


# Cell
def non_contextual_categorical_bandit(choice:int, theta:np.array)->bool:

    # draw a number between 0 and 1, if it's smaller than the theta, return reward
    if np.random.random() < theta[choice]:
        reaction = True
    else:
        reaction = False

    return reaction

# Cell
def contextual_categorical_bandit(context:np.array, choice:int, theta:np.array, noise:float):
    y = 0

    for dim in np.atleast_1d(context):
        y+= theta[choice] * dim

    p = sigmoid(y)

    return np.random.choice([0,1],p=[1-p,p]), max(theta) - p, p

def contextual_categorical_get_optimal_arm(context):
    if context < 0:
        return 1
    return 0

# Cell
class NonlinearContextualCategoricalBandit(AbstractContextualMAB):

    def get_probability(self, choice, context):
        y = 0 #self.theta[choice]

        for dim in np.atleast_1d(context):
            y+= np.sin(self.theta[choice] * (dim+1) + dim +  np.random.normal(0,self.noise))

        return self.activation(y)

    def get_reward(self, choice, context):
        p = self.get_probability(choice, context)
        return np.random.choice([0,1],p=[1-p,p]), max(self.theta) - p, p

    def get_optimal_arm(self, context):
        arm_ps = []
        for i in range(self.num_arms):
            arm_ps.append(self.get_probability(i, context))

        return np.argmax(arm_ps)

# Cell
def contextual_numerical_bandit(context:np.array, choice:int, theta:np.array, noise=float)->float:
    features  = np.append(context,choice)

    # decide on which slope to use depending on whether a dog is present or not
    m = theta[0] if features[1] else theta[1]
    intercept = 0 if features[1] else 0

    # $y = x \cdot m + t + \epsilon $
    y = features[0] * m + intercept +  np.random.normal(0,noise)


    return y